// Generated by CoffeeScript 1.9.3

/*
 * The Engine class is the central point for creating and managing your game state. Add
 * entities and systems to the engine, and fetch families of nodes from the engine.
 *
 * This version is implemented as a Phaser Plugin. It uses the Phaser update cycle
 * to provide tick for the ash engine update.
 *
 * Use this version if Phaser drives the updates
 */

(function() {
  var PhaserPlugin,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  if (typeof Phaser !== "undefined" && Phaser !== null) {
    ash.ext.PhaserPlugin = PhaserPlugin = (function(superClass) {
      extend(PhaserPlugin, superClass);

      PhaserPlugin.prototype.entityNames = null;

      PhaserPlugin.prototype.entityList = null;

      PhaserPlugin.prototype.systemList = null;

      PhaserPlugin.prototype.families = null;

      PhaserPlugin.prototype.nodes = null;

      PhaserPlugin.prototype.components = null;


      /*
       * Phaser.Plugin members
       */

      PhaserPlugin.prototype.game = null;

      PhaserPlugin.prototype.parent = null;

      PhaserPlugin.prototype.active = true;

      PhaserPlugin.prototype.visible = true;

      PhaserPlugin.prototype.hasPostRender = true;


      /*
       * Indicates if the engine is currently in its update loop.
       */

      PhaserPlugin.prototype.updating = false;


      /*
       * Dispatched when the update loop ends. If you want to add and remove systems from the
       * engine it is usually best not to do so during the update loop. To avoid this you can
       * listen for this signal and make the change when the signal is dispatched.
       */

      PhaserPlugin.prototype.updateComplete = null;


      /*
       * The class used to manage node lists. In most cases the default class is sufficient
       * but it is exposed here so advanced developers can choose to create and use a
       * different implementation.
       *
       * The class must implement the IFamily interface.
       */

      PhaserPlugin.prototype.familyClass = ComponentMatchingFamily;


      /*
       * @param game      the current phaser game context
       * @param parent    the current phaser state context
       */

      function PhaserPlugin(game, parent) {
        this.update = bind(this.update, this);
        this.removeAllSystems = bind(this.removeAllSystems, this);
        this.removeSystem = bind(this.removeSystem, this);
        this.getSystem = bind(this.getSystem, this);
        this.addSystem = bind(this.addSystem, this);
        this.releaseNodeList = bind(this.releaseNodeList, this);
        this.getNodeList = bind(this.getNodeList, this);
        this.componentRemoved = bind(this.componentRemoved, this);
        this.componentAdded = bind(this.componentAdded, this);
        this.removeAllEntities = bind(this.removeAllEntities, this);
        this.getEntityByName = bind(this.getEntityByName, this);
        this.entityNameChanged = bind(this.entityNameChanged, this);
        this.removeEntity = bind(this.removeEntity, this);
        this.addEntity = bind(this.addEntity, this);
        this.init = bind(this.init, this);
        PhaserPlugin.__super__.constructor.call(this, game, parent);
        this.nodes = {};
        this.components = {};
        this.entityList = new EntityList();
        this.entityNames = new Dictionary();
        this.systemList = new SystemList();
        this.families = new Dictionary();
        this.updateComplete = new Signal0();
      }

      PhaserPlugin.prototype.addNode = function(name, def) {
        var property, ref, type;
        if (def.components == null) {
          def.components = {};
          ref = def.prototype;
          for (property in ref) {
            if (!hasProp.call(ref, property)) continue;
            type = ref[property];
            def.components[property] = type;
            def.prototype[property] = null;
          }
          def.prototype.entity = null;
          def.prototype.previous = null;
          def.prototype.next = null;
        }
        return this.nodes[name] = def;
      };

      PhaserPlugin.prototype.init = function(nodes, components) {

        /*
         * register components
         */
        var klass, name, property, ref, results, type;
        if (components != null) {
          for (name in components) {
            klass = components[name];
            this.components[name] = klass;
          }
        }

        /*
         * register nodes
         */
        if (nodes != null) {
          results = [];
          for (name in nodes) {
            klass = nodes[name];

            /*
             * convert template to an actual node class
             */
            if (klass.components == null) {
              klass.components = {};
              ref = klass.prototype;
              for (property in ref) {
                if (!hasProp.call(ref, property)) continue;
                type = ref[property];
                klass.components[property] = type;
                klass.prototype[property] = null;
              }
              klass.prototype.entity = null;
              klass.prototype.previous = null;
              klass.prototype.next = null;
            }
            if (components != null) {
              results.push(this.nodes[name] = klass);
            } else {
              results.push(void 0);
            }
          }
          return results;
        }
      };

      Object.defineProperties(PhaserPlugin.prototype, {

        /*
         * Returns a vector containing all the entities in the engine.
         */
        entities: {
          get: function() {
            var entities, entity;
            entities = [];
            entity = this.entityList.head;
            while (entity) {
              this.entities.push(entity);
              entity = entity.next;
            }
            return entities;
          }

          /*
           * Returns a vector containing all the systems in the engine.
           */
        },
        systems: {
          get: function() {
            var system, systems;
            systems = [];
            system = this.systemList.head;
            while (system) {
              systems.push(system);
              system = system.next;
            }
            return systems;
          }
        }
      });


      /*
       * Add an entity to the engine.
       *
       * @param entity The entity to add.
       */

      PhaserPlugin.prototype.addEntity = function(entity) {
        var each, family, ref;
        if (this.entityNames[entity.name]) {
          throw "The entity name " + entity.name + " is already in use by another entity.";
        }
        this.entityList.add(entity);
        this.entityNames[entity.name] = entity;
        entity.componentAdded.add(this.componentAdded);
        entity.componentRemoved.add(this.componentRemoved);
        entity.nameChanged.add(this.entityNameChanged);
        ref = this.families;
        for (each in ref) {
          family = ref[each];
          family.newEntity(entity);
        }
      };


      /*
       * Remove an entity from the engine.
       *
       * @param entity The entity to remove.
       */

      PhaserPlugin.prototype.removeEntity = function(entity) {
        var each, family, ref;
        entity.componentAdded.remove(this.componentAdded);
        entity.componentRemoved.remove(this.componentRemoved);
        entity.nameChanged.remove(this.entityNameChanged);
        ref = this.families;
        for (each in ref) {
          family = ref[each];
          family.removeEntity(entity);
        }
        delete this.entityNames[entity.name];
        this.entityList.remove(entity);
      };

      PhaserPlugin.prototype.entityNameChanged = function(entity, oldName) {
        if (this.entityNames[oldName] === entity) {
          delete this.entityNames[oldName];
          this.entityNames[entity.name] = entity;
        }
      };


      /*
       * Get an entity based n its name.
       *
       * @param name The name of the entity
       * @return The entity, or null if no entity with that name exists on the engine
       */

      PhaserPlugin.prototype.getEntityByName = function(name) {
        return this.entityNames[name];
      };


      /*
       * Remove all entities from the engine.
       */

      PhaserPlugin.prototype.removeAllEntities = function() {
        while (this.entityList.head !== null) {
          this.removeEntity(this.entityList.head);
        }
      };


      /*
       @private
       */

      PhaserPlugin.prototype.componentAdded = function(entity, componentClass) {
        var each, family, ref;
        ref = this.families;
        for (each in ref) {
          family = ref[each];
          family.componentAddedToEntity(entity, componentClass);
        }
      };


      /*
       @private
       */

      PhaserPlugin.prototype.componentRemoved = function(entity, componentClass) {
        var each, family, ref;
        ref = this.families;
        for (each in ref) {
          family = ref[each];
          family.componentRemovedFromEntity(entity, componentClass);
        }
      };


      /*
       * Get a collection of nodes from the engine, based on the type of the node required.
       *
       * <p>The engine will create the appropriate NodeList if it doesn't already exist and
       * will keep its contents up to date as entities are added to and removed from the
       * engine.</p>
       *
       * <p>If a NodeList is no longer required, release it with the releaseNodeList method.</p>
       *
       * @param nodeClass The type of node required.
       * @return A linked list of all nodes of this type from all entities in the engine.
       */

      PhaserPlugin.prototype.getNodeList = function(nodeClass) {
        var entity, family;
        if (nodeClass.name in this.families) {
          return this.families[nodeClass.name].nodeList;
        }
        family = new this.familyClass(nodeClass, this);
        this.families[nodeClass.name] = family;
        entity = this.entityList.head;
        while (entity) {
          family.newEntity(entity);
          entity = entity.next;
        }
        return family.nodeList;
      };


      /*
       * If a NodeList is no longer required, this method will stop the engine updating
       * the list and will release all references to the list within the framework
       * classes, enabling it to be garbage collected.
       *
       * <p>It is not essential to release a list, but releasing it will free
       * up memory and processor resources.</p>
       *
       * @param nodeClass The type of the node class if the list to be released.
       */

      PhaserPlugin.prototype.releaseNodeList = function(nodeClass) {
        if (nodeClass.name in this.families) {
          this.families[nodeClass.name].cleanUp();
          delete this.families[nodeClass.name];
        }
      };


      /*
       * Add a system to the engine, and set its priority for the order in which the
       * systems are updated by the engine update loop.
       *
       * <p>The priority dictates the order in which the systems are updated by the engine update
       * loop. Lower numbers for priority are updated first. i.e. a priority of 1 is
       * updated before a priority of 2.</p>
       *
       * @param system The system to add to the engine.
       * @param priority The priority for updating the systems during the engine loop. A
       * lower number means the system is updated sooner.
       */

      PhaserPlugin.prototype.addSystem = function(system, priority) {
        system.priority = priority;
        system.addToEngine(this);
        this.systemList.add(system);
      };


      /*
       * Get the system instance of a particular type from within the engine.
       *
       * @param type The type of system
       * @return The instance of the system type that is in the engine, or
       * null if no systems of this type are in the engine.
       */

      PhaserPlugin.prototype.getSystem = function(type) {
        return systemList.get(type);
      };


      /*
       * Remove a system from the engine.
       *
       * @param system The system to remove from the engine.
       */

      PhaserPlugin.prototype.removeSystem = function(system) {
        this.systemList.remove(system);
        system.removeFromEngine(this);
      };


      /*
       * Remove all systems from the engine.
       */

      PhaserPlugin.prototype.removeAllSystems = function() {
        while (this.systemList.head !== null) {
          this.removeSystem(this.systemList.head);
        }
      };


      /*
       * update
       *
       * Phaser.Plugin interface
       *
       * Update the engine. This causes the engine update loop to run, calling update on all the
       * systems in the engine.
       *
       * <p>The package ash.tick contains classes that can be used to provide
       * a steady or variable tick that calls this update method.</p>
       *
       * @time The duration, in seconds, of this update step.
       */

      PhaserPlugin.prototype.update = function() {
        var system, time;
        time = this.game.time.elapsed * 0.001;
        this.updating = true;
        system = this.systemList.head;
        while (system) {
          system.update(time);
          system = system.next;
        }
        this.updating = false;
        this.updateComplete.dispatch();
      };

      return PhaserPlugin;

    })(Phaser.Plugin);
  }

}).call(this);

//# sourceMappingURL=phaser_plugin.js.map
