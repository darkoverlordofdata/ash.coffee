// Generated by CoffeeScript 1.9.3

/*
 * The Engine class is the central point for creating and managing your game state. Add
 * entities and systems to the engine, and fetch families of nodes from the engine.
 */

(function() {
  'use strict';
  var Dictionary, EntityList, Signal0, SystemList, getClassName,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  EntityList = ash.core.EntityList;

  Dictionary = ash.ext.Dictionary;

  SystemList = ash.core.SystemList;

  Signal0 = ash.signals.Signal0;

  getClassName = ash.ext.getClassName;

  ash.core.Engine = (function() {
    Engine.prototype.entityNames = null;

    Engine.prototype.entityList = null;

    Engine.prototype.systemList = null;

    Engine.prototype.families = null;


    /*
     * Indicates if the engine is currently in its update loop.
     */

    Engine.prototype.updating = false;


    /*
     * Dispatched when the update loop ends. If you want to add and remove systems from the
     * engine it is usually best not to do so during the update loop. To avoid this you can
     * listen for this signal and make the change when the signal is dispatched.
     */

    Engine.prototype.updateComplete = null;


    /*
     * The class used to manage node lists. In most cases the default class is sufficient
     * but it is exposed here so advanced developers can choose to create and use a
     * different implementation.
     *
     * The class must implement the IFamily interface.
     */

    Engine.prototype.familyClass = ash.core.ComponentMatchingFamily;

    function Engine() {
      this.update = bind(this.update, this);
      this.componentRemoved = bind(this.componentRemoved, this);
      this.componentAdded = bind(this.componentAdded, this);
      this.entityNameChanged = bind(this.entityNameChanged, this);
      this.entityList = new EntityList();
      this.entityNames = new Dictionary();
      this.systemList = new SystemList();
      this.families = new Dictionary();
      this.updateComplete = new Signal0();
    }

    Object.defineProperties(Engine.prototype, {

      /*
       * Returns a vector containing all the entities in the engine.
       */
      entities: {
        get: function() {
          var entities, entity;
          entities = [];
          entity = this.entityList.head;
          while (entity) {
            this.entities.push(entity);
            entity = entity.next;
          }
          return entities;
        }

        /*
         * Returns a vector containing all the systems in the engine.
         */
      },
      systems: {
        get: function() {
          var system, systems;
          systems = [];
          system = this.systemList.head;
          while (system) {
            systems.push(system);
            system = system.next;
          }
          return systems;
        }
      }
    });


    /*
     * Add an entity to the engine.
     *
     * @param entity The entity to add.
     */

    Engine.prototype.addEntity = function(entity) {
      var each, family, ref;
      if (this.entityNames[entity.name]) {
        throw "The entity name " + entity.name + " is already in use by another entity.";
      }
      this.entityList.add(entity);
      this.entityNames[entity.name] = entity;
      entity.componentAdded.add(this.componentAdded);
      entity.componentRemoved.add(this.componentRemoved);
      entity.nameChanged.add(this.entityNameChanged);
      ref = this.families;
      for (each in ref) {
        family = ref[each];
        family.newEntity(entity);
      }
    };


    /*
     * Remove an entity from the engine.
     *
     * @param entity The entity to remove.
     */

    Engine.prototype.removeEntity = function(entity) {
      var each, family, ref;
      entity.componentAdded.remove(this.componentAdded);
      entity.componentRemoved.remove(this.componentRemoved);
      entity.nameChanged.remove(this.entityNameChanged);
      ref = this.families;
      for (each in ref) {
        family = ref[each];
        family.removeEntity(entity);
      }
      delete this.entityNames[entity.name];
      this.entityList.remove(entity);
    };

    Engine.prototype.entityNameChanged = function(entity, oldName) {
      if (this.entityNames[oldName] === entity) {
        delete this.entityNames[oldName];
        this.entityNames[entity.name] = entity;
      }
    };


    /*
     * Get an entity based n its name.
     *
     * @param name The name of the entity
     * @return The entity, or null if no entity with that name exists on the engine
     */

    Engine.prototype.getEntityByName = function(name) {
      return this.entityNames[name];
    };


    /*
     * Remove all entities from the engine.
     */

    Engine.prototype.removeAllEntities = function() {
      while (this.entityList.head !== null) {
        this.removeEntity(this.entityList.head);
      }
    };


    /*
     @private
     */

    Engine.prototype.componentAdded = function(entity, componentClass) {
      var each, family, ref;
      ref = this.families;
      for (each in ref) {
        family = ref[each];
        family.componentAddedToEntity(entity, componentClass);
      }
    };


    /*
     @private
     */

    Engine.prototype.componentRemoved = function(entity, componentClass) {
      var each, family, ref;
      ref = this.families;
      for (each in ref) {
        family = ref[each];
        family.componentRemovedFromEntity(entity, componentClass);
      }
    };


    /*
     * Get a collection of nodes from the engine, based on the type of the node required.
     *
     * <p>The engine will create the appropriate NodeList if it doesn't already exist and
     * will keep its contents up to date as entities are added to and removed from the
     * engine.</p>
     *
     * <p>If a NodeList is no longer required, release it with the releaseNodeList method.</p>
     *
     * @param nodeClass The type of node required.
     * @return A linked list of all nodes of this type from all entities in the engine.
     */

    Engine.prototype.getNodeList = function(nodeClass) {
      var entity, family;
      if (getClassName(nodeClass) in this.families) {
        return this.families[getClassName(nodeClass)].nodeList;
      }
      family = new this.familyClass(nodeClass, this);
      this.families[getClassName(nodeClass)] = family;
      entity = this.entityList.head;
      while (entity) {
        family.newEntity(entity);
        entity = entity.next;
      }
      return family.nodeList;
    };


    /*
     * If a NodeList is no longer required, this method will stop the engine updating
     * the list and will release all references to the list within the framework
     * classes, enabling it to be garbage collected.
     *
     * <p>It is not essential to release a list, but releasing it will free
     * up memory and processor resources.</p>
     *
     * @param nodeClass The type of the node class if the list to be released.
     */

    Engine.prototype.releaseNodeList = function(nodeClass) {
      if (getClassName(nodeClass) in this.families) {
        this.families[getClassName(nodeClass)].cleanUp();
        delete this.families[getClassName(nodeClass)];
      }
    };


    /*
     * Add a system to the engine, and set its priority for the order in which the
     * systems are updated by the engine update loop.
     *
     * <p>The priority dictates the order in which the systems are updated by the engine update
     * loop. Lower numbers for priority are updated first. i.e. a priority of 1 is
     * updated before a priority of 2.</p>
     *
     * @param system The system to add to the engine.
     * @param priority The priority for updating the systems during the engine loop. A
     * lower number means the system is updated sooner.
     */

    Engine.prototype.addSystem = function(system, priority) {
      system.priority = priority;
      system.addToEngine(this);
      this.systemList.add(system);
    };


    /*
     * Get the system instance of a particular type from within the engine.
     *
     * @param type The type of system
     * @return The instance of the system type that is in the engine, or
     * null if no systems of this type are in the engine.
     */

    Engine.prototype.getSystem = function(type) {
      return systemList.get(type);
    };


    /*
     * Remove a system from the engine.
     *
     * @param system The system to remove from the engine.
     */

    Engine.prototype.removeSystem = function(system) {
      this.systemList.remove(system);
      system.removeFromEngine(this);
    };


    /*
     * Remove all systems from the engine.
     */

    Engine.prototype.removeAllSystems = function() {
      while (this.systemList.head !== null) {
        this.removeSystem(this.systemList.head);
      }
    };


    /*
     * Update the engine. This causes the engine update loop to run, calling update on all the
     * systems in the engine.
     *
     * <p>The package ash.tick contains classes that can be used to provide
     * a steady or variable tick that calls this update method.</p>
     *
     * @time The duration, in seconds, of this update step.
     */

    Engine.prototype.update = function(time) {
      var system;
      this.updating = true;
      system = this.systemList.head;
      while (system) {
        system.update(time);
        system = system.next;
      }
      this.updating = false;
      this.updateComplete.dispatch();
    };

    return Engine;

  })();

}).call(this);

//# sourceMappingURL=Engine.js.map
