// Generated by CoffeeScript 1.9.0

/*

   _       _
  /_\  ___| |__
 //_\\/ __| '_ \
/  _  \__ \ | | |
\_/ \_/___/_| |_|

              __  __
    ___ ___  / _|/ _| ___  ___
   / __/ _ \| |_| |_ / _ \/ _ \
  | (_| (_) |  _|  _|  __/  __/
 (_)___\___/|_| |_|  \___|\___|


Copyright (c) 2015 Bruce Davidson &lt;darkoverlordofdata@gmail.com&gt;

Author: Richard Lord
Copyright (c) Richard Lord 2011-2012
http://www.richardlord.net


Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
'Software'), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

(function() {
  'use strict';

  /*
   * ash namespace
   * @const
   */
  var ComponentInstanceProvider, ComponentMatchingFamily, ComponentSingletonProvider, ComponentTypeProvider, Dictionary, DynamicComponentProvider, DynamicSystemProvider, EngineState, EntityList, EntityState, ListenerNode, ListenerNodePool, NodeList, NodePool, Signal0, Signal1, Signal2, StateComponentMapping, StateSystemMapping, SystemInstanceProvider, SystemList, SystemSingletonProvider, Util, ash,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __hasProp = {}.hasOwnProperty,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  ash = {
    core: {},
    ext: {},
    fsm: {},
    signals: {},
    tick: {},
    tools: {}
  };

  (function(root, factory) {
    'use strict';

    /*
     * Export ash - umd header
     */
    if ('function' === typeof define && define.amd) {
      define(factory);
    } else if ('object' === typeof exports) {
      module.exports = factory();
    } else {
      root['ash'] = factory();
    }
  })(this, (function() {
    return ash;
  }));


  /*
   * A node in the list of listeners in a signal.
   */

  'use strict';


  /**
   * @constructor
   */

  ash.signals.ListenerNode = (function() {
    function ListenerNode() {}


    /**
     * @param {ash.signals.ListenerNode}
     */

    ListenerNode.prototype.previous = null;


    /**
     * @param {ash.signals.ListenerNode}
     */

    ListenerNode.prototype.next = null;


    /**
     * @param {ash.signals.SignalBase}
     */

    ListenerNode.prototype.listener = null;


    /**
     * @param {boolean}
     */

    ListenerNode.prototype.once = false;

    return ListenerNode;

  })();


  /*
   * This internal class maintains a pool of deleted listener nodes for reuse by framework. This reduces
   * the overhead from object creation and garbage collection.
   */

  'use strict';

  ListenerNode = ash.signals.ListenerNode;


  /**
   * @constructor
   */

  ash.signals.ListenerNodePool = (function() {
    function ListenerNodePool() {}


    /**
     * @type {ash.signals.ListenerNodePool}
     */

    ListenerNodePool.prototype.tail = null;


    /**
     * @type {ash.signals.ListenerNodePool}
     */

    ListenerNodePool.prototype.cacheTail = null;


    /**
     * Get listener node
     * @return {ash.signals.ListenerNode}
     */

    ListenerNodePool.prototype.get = function() {
      var node;
      if (this.tail !== null) {
        node = this.tail;
        this.tail = this.tail.previous;
        node.previous = null;
        return node;
      } else {
        return new ListenerNode();
      }
    };


    /**
     * Dispose of listener node
     * @param {ash.signals.ListenerNode}
     */

    ListenerNodePool.prototype.dispose = function(node) {
      node.listener = null;
      node.once = false;
      node.next = null;
      node.previous = this.tail;
      this.tail = node;
    };


    /**
     * Cache listener node
     * @param {ash.signals.ListenerNode}
     */

    ListenerNodePool.prototype.cache = function(node) {
      node.listener = null;
      node.previous = this.cacheTail;
      this.cacheTail = node;
    };


    /**
     * Release cache
     */

    ListenerNodePool.prototype.releaseCache = function() {
      var node;
      while (this.cacheTail !== null) {
        node = this.cacheTail;
        this.cacheTail = node.previous;
        node.next = null;
        node.previous = this.tail;
        this.tail = node;
      }
    };

    return ListenerNodePool;

  })();

  'use strict';

  ListenerNodePool = ash.signals.ListenerNodePool;

  ash.signals.SignalBase = (function() {

    /**
     * @type {ash.signals.ListenerNode}
     */
    SignalBase.prototype.head = null;


    /**
     * @type {ash.signals.ListenerNode}
     */

    SignalBase.prototype.tail = null;


    /**
     * @type {number}
     */

    SignalBase.prototype.numListeners = 0;


    /**
     * @type {Array<Object>}
     */

    SignalBase.prototype.keys = null;


    /**
     * @type {ash.signals.ListenerNode}
     */

    SignalBase.prototype.nodes = null;


    /**
     * @type {ash.signals.ListenerNodePool}
     */

    SignalBase.prototype.listenerNodePool = null;


    /**
     * @type {ash.signals.ListenerNode}
     */

    SignalBase.prototype.toAddHead = null;


    /**
     * @type {ash.signals.ListenerNode}
     */

    SignalBase.prototype.toAddTail = null;


    /**
     * @type {boolean}
     */

    SignalBase.prototype.dispatching = false;


    /**
     * @constructor
     */

    function SignalBase() {
      this.nodes = [];
      this.keys = [];
      this.listenerNodePool = new ListenerNodePool();
      this.numListeners = 0;
    }


    /**
     */

    SignalBase.prototype.startDispatch = function() {
      this.dispatching = true;
    };


    /**
     */

    SignalBase.prototype.endDispatch = function() {
      this.dispatching = false;
      if (this.toAddHead) {
        if (!this.head) {
          this.head = this.toAddHead;
          this.tail = this.toAddTail;
        } else {
          this.tail.next = this.toAddHead;
          this.toAddHead.previous = this.tail;
          this.tail = this.toAddTail;
        }
        this.toAddHead = null;
        this.toAddTail = null;
      }
      this.listenerNodePool.releaseCache();
    };


    /**
     * @param {Object} listener
     */

    SignalBase.prototype.getNode = function(listener) {
      var node;
      node = this.head;
      while (node !== null) {
        if (node.listener === listener) {
          break;
        }
        node = node.next;
      }
      if (node === null) {
        node = this.toAddHead;
        while (node !== null) {
          if (node.listener === listener) {
            break;
          }
          node = node.next;
        }
      }
      return node;
    };


    /**
     * @param {Object} listener
     */

    SignalBase.prototype.add = function(listener) {
      var node;
      if (this.keys.indexOf(listener) !== -1) {
        return;
      }
      node = this.listenerNodePool.get();
      node.listener = listener;
      this.nodes.push(node);
      this.keys.push(listener);
      this.addNode(node);
    };


    /**
     * @param {Object} listener
     */

    SignalBase.prototype.addOnce = function(listener) {
      var node;
      if (this.keys.indexOf(listener) !== -1) {
        return;
      }
      node = this.listenerNodePool.get();
      node.listener = listener;
      node.once = true;
      this.nodes.push(node);
      this.keys.push(listener);
      this.addNode(node);
    };


    /**
     * @param {ash.signals.ListenerNode} node
     */

    SignalBase.prototype.addNode = function(node) {
      if (this.dispatching) {
        if (this.toAddHead === null) {
          this.toAddHead = this.toAddTail = node;
        } else {
          this.toAddTail.next = node;
          node.previous = this.toAddTail;
          this.toAddTail = node;
        }
      } else {
        if (this.head === null) {
          this.head = this.tail = node;
        } else {
          this.tail.next = node;
          node.previous = this.tail;
          this.tail = node;
        }
      }
      this.numListeners++;
    };


    /**
     * @param {Object} listener
     */

    SignalBase.prototype.remove = function(listener) {
      var index, node;
      index = this.keys.indexOf(listener);
      node = this.nodes[index];
      if (node) {
        if (this.head === node) {
          this.head = this.head.next;
        }
        if (this.tail === node) {
          this.tail = this.tail.previous;
        }
        if (this.toAddHead === node) {
          this.toAddHead = this.toAddHead.next;
        }
        if (this.toAddTail === node) {
          this.toAddTail = this.toAddTail.previous;
        }
        if (node.previous) {
          node.previous.next = node.next;
        }
        if (node.next) {
          node.next.previous = node.previous;
        }
        this.nodes.splice(index, 1);
        this.keys.splice(index, 1);
        if (this.dispatching) {
          this.listenerNodePool.cache(node);
        } else {
          this.listenerNodePool.dispose(node);
        }
        this.numListeners--;
      }
    };


    /**
     */

    SignalBase.prototype.removeAll = function() {
      var index, node;
      while (this.head) {
        node = this.head;
        this.head = this.head.next;
        index = this.keys.indexOf(node.listener);
        this.nodes.splice(index, 1);
        this.listenerNodePool.dispose(node);
      }
      this.nodes = [];
      this.keys = [];
      this.tail = null;
      this.toAddHead = null;
      this.toAddTail = null;
      this.numListeners = 0;
    };

    return SignalBase;

  })();

  'use strict';


  /**
   * @extends {ash.signals.SignalBase}
   * @constructor
   */

  ash.signals.Signal0 = (function(_super) {
    __extends(Signal0, _super);

    function Signal0() {
      return Signal0.__super__.constructor.apply(this, arguments);
    }


    /**
     * dispatch the event
     */

    Signal0.prototype.dispatch = function() {
      var node;
      this.startDispatch();
      node = this.head;
      while (node !== null) {
        node.listener();
        if (node.once) {
          this.remove(node.listener);
        }
        node = node.next;
      }
      return this.endDispatch();
    };

    return Signal0;

  })(ash.signals.SignalBase);

  'use strict';


  /**
   * @extends {ash.signals.SignalBase}
   * @constructor
   */

  ash.signals.Signal1 = (function(_super) {
    __extends(Signal1, _super);

    function Signal1() {
      return Signal1.__super__.constructor.apply(this, arguments);
    }


    /**
     * dispatch the event
     * @param {any}
     */

    Signal1.prototype.dispatch = function($1) {
      var node;
      this.startDispatch();
      node = this.head;
      while (node !== null) {
        node.listener($1);
        if (node.once) {
          this.remove(node.listener);
        }
        node = node.next;
      }
      return this.endDispatch();
    };

    return Signal1;

  })(ash.signals.SignalBase);

  'use strict';


  /**
   * @extends {ash.signals.SignalBase}
   * @constructor
   */

  ash.signals.Signal2 = (function(_super) {
    __extends(Signal2, _super);

    function Signal2() {
      return Signal2.__super__.constructor.apply(this, arguments);
    }


    /**
     * dispatch the event
     * @param {any} 
     * @param {any}
     */

    Signal2.prototype.dispatch = function($1, $2) {
      var node;
      this.startDispatch();
      node = this.head;
      while (node) {
        node.listener($1, $2);
        if (node.once) {
          this.remove(node.listener);
        }
        node = node.next;
      }
      return this.endDispatch();
    };

    return Signal2;

  })(ash.signals.SignalBase);

  'use strict';


  /**
   * @extends {ash.signals.SignalBase}
   * @constructor
   */

  ash.signals.Signal3 = (function(_super) {
    __extends(Signal3, _super);

    function Signal3() {
      return Signal3.__super__.constructor.apply(this, arguments);
    }


    /**
     * dispatch the event
     * @param {any} 
     * @param {any} 
     * @param {any}
     */

    Signal3.prototype.dispatch = function($1, $2, $3) {
      var node;
      this.startDispatch();
      node = this.head;
      while (node !== null) {
        node.listener($1, $2, $3);
        if (node.once) {
          this.remove(node.listener);
        }
        node = node.next;
      }
      return this.endDispatch();
    };

    return Signal3;

  })(ash.signals.SignalBase);


  /*
   * An entity is composed from components. As such, it is essentially a collection object for components.
   * Sometimes, the entities in a game will mirror the actual characters and objects in the game, but this
   * is not necessary.
   *
   * <p>Components are simple value objects that contain data relevant to the entity. Entities
   * with similar functionality will have instances of the same components. So we might have
   * a position component</p>
   *
   * <p><code>class PositionComponent
   * {
   *   public var x:Float;
   *   public var y:Float;
   * }</code></p>
   *
   * <p>All entities that have a position in the game world, will have an instance of the
   * position component. Systems operate on entities based on the components they have.</p>
   */

  'use strict';

  Signal2 = ash.signals.Signal2;

  Dictionary = ash.ext.Dictionary;

  Util = ash.ext.Util;

  ash.core.Entity = (function() {
    var nameCount;

    Entity.nameCount = {};

    nameCount = 0;


    /**
     * Optional, give the entity a name. This can help with debugging and with serialising the entity.
     *
     * @type {string}
     */

    Entity.prototype.name = '';


    /**
     * This signal is dispatched when a component is added to the entity.
     * 
     * @type {ash.signals.Signal2}
     */

    Entity.prototype.componentAdded = null;


    /**
     * This signal is dispatched when a component is removed from the entity.
     * 
     * @type {ash.signals.Signal2}
     */

    Entity.prototype.componentRemoved = null;


    /**
     * Dispatched when the name of the entity changes. Used internally by the engine to track entities based on their names.
     * 
     * @type {ash.signals.Signal2}
     */

    Entity.prototype.nameChanged = null;

    Entity.prototype.previous = null;

    Entity.prototype.next = null;

    Entity.prototype.components = null;


    /**
     * @constructor
     * @param {string} name Entity name
     */

    function Entity(name) {
      if (name == null) {
        name = '';
      }
      this.componentAdded = new Signal2();
      this.componentRemoved = new Signal2();
      this.nameChanged = new Signal2();
      this.components = new Dictionary();
      if (name !== '') {
        if (Entity.nameCount[name] == null) {
          Entity.nameCount[name] = 0;
        }
        this.name = name + (++Entity.nameCount[name]);
      } else {
        this.name = "_entity" + (++nameCount);
      }
    }


    /**
     * All entities have a name. If no name is set, a default name is used. Names are used to
     * fetch specific entities from the engine, and can also help to identify an entity when debugging.
     * @param {string} value
     */

    Entity.prototype.setName = function(value) {
      var previous;
      if (this.name !== value) {
        previous = this.name;
        this.name = value;
        this.nameChanged.dispatch(this, previous);
      }
    };


    /**
     * Add a component to the entity.
     *
     * @param {Object} component The component object to add.
     * @param {Object} componentClass The class of the component. This is only necessary if the component
     * extends another component class and you want the framework to treat the component as of
     * the base class type. If not set, the class type is determined directly from the component.
     *
     * @return {ash.core.Entity} A reference to the entity. This enables the chaining of calls to add, to make
     * creating and configuring entities cleaner. e.g.
     *
     * <code>var entity:Entity = new Entity()
     *     .add(new Position(100, 200)
     *     .add(new Display(new PlayerClip());</code>
     */

    Entity.prototype.add = function(component, componentClass) {
      if (componentClass == null) {
        componentClass = component.constructor;
      }
      if (Util.getClassName(componentClass) in this.components) {
        this.remove(componentClass);
      }
      this.components[Util.getClassName(componentClass)] = component;
      this.componentAdded.dispatch(this, componentClass);
      return this;
    };


    /**
     * Remove a component from the entity.
     *
     * @param {Object} componentClass The class of the component to be removed.
     * @return {Object} the component, or null if the component doesn't exist in the entity
     */

    Entity.prototype.remove = function(componentClass) {
      var component, name;
      name = Util.getClassName(componentClass) != null ? Util.getClassName(componentClass) : componentClass;
      component = this.components[name];
      if (component) {
        delete this.components[name];
        this.componentRemoved.dispatch(this, name);
        return component;
      }
      return null;
    };


    /**
     * Get a component from the entity.
     *
     * @param {Object} componentClass The class of the component requested.
     * @return {Object} The component, or null if none was found.
     */

    Entity.prototype.get = function(componentClass) {
      return this.components[Util.getClassName(componentClass)];
    };


    /**
     * Get all components from the entity.
     *
     * @return {Array<Object>} An array containing all the components that are on the entity.
     */

    Entity.prototype.getAll = function() {
      var component, componentArray, _i, _len, _ref;
      componentArray = [];
      _ref = this.components;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        component = _ref[_i];
        componentArray.push(component);
      }
      return componentArray;
    };


    /**
     * Does the entity have a component of a particular type.
     *
     * @param {Object} componentClass The class of the component sought.
     * @return {boolean} true if the entity has a component of the type, false if not.
     */

    Entity.prototype.has = function(componentClass) {
      return Util.getClassName(componentClass) in this.components;
    };

    return Entity;

  })();


  /*
   * An internal class for a linked list of entities. Used inside the framework for
   * managing the entities.
   */

  'use strict';


  /**
   * @constructor
   */

  ash.core.EntityList = (function() {
    function EntityList() {}


    /**
     * @type {ash.core.Entity}
     */

    EntityList.prototype.head = null;


    /**
     * @type {ash.core.Entity}
     */

    EntityList.prototype.tail = null;


    /**
     * Add an entity to the list
     *
     * @param {ash.core.Entity}
     */

    EntityList.prototype.add = function(entity) {
      if (!this.head) {
        this.head = this.tail = entity;
        entity.next = entity.previous = null;
      } else {
        this.tail.next = entity;
        entity.previous = this.tail;
        entity.next = null;
        this.tail = entity;
      }
    };


    /**
     * Remove an entity from the list
     *
     * @param {ash.core.Entity}
     */

    EntityList.prototype.remove = function(entity) {
      if (this.head === entity) {
        this.head = this.head.next;
      }
      if (this.tail === entity) {
        this.tail = this.tail.previous;
      }
      if (entity.previous) {
        entity.previous.next = entity.next;
      }
      if (entity.next) {
        entity.next.previous = entity.previous;
      }
    };


    /**
     * Remove all entities
     */

    EntityList.prototype.removeAll = function() {
      var entity;
      while (this.head) {
        entity = this.head;
        this.head = this.head.next;
        entity.previous = null;
        entity.next = null;
      }
      this.tail = null;
    };

    return EntityList;

  })();

  'use strict';


  /**
   * @constructor
   */

  ash.core.Node = (function() {
    function Node() {}


    /**
     * @type {ash.core.Entity}
     */

    Node.prototype.entity = null;


    /**
     * @type {ash.core.Node}
     */

    Node.prototype.previous = null;


    /**
     * @type {ash.core.Node}
     */

    Node.prototype.next = null;

    return Node;

  })();


  /*
   * A collection of nodes.
   *
   * <p>Systems within the engine access the components of entities via NodeLists. A NodeList contains
   * a node for each Entity in the engine that has all the components required by the node. To iterate
   * over a NodeList, start from the head and step to the next on each loop, until the returned value
   * is null. Or just use for in syntax.</p>
   *
   * <p>for (node in nodeList)
   * {
   *   // do stuff
   * }</p>
   *
   * <p>It is safe to remove items from a nodelist during the loop. When a Node is removed form the
   * NodeList it's previous and next properties still point to the nodes that were before and after
   * it in the NodeList just before it was removed.</p>
   */

  'use strict';

  Signal1 = ash.signals.Signal1;

  ash.core.NodeList = (function() {

    /**
     * The first item in the node list, or null if the list contains no nodes.
     * @type {ash.core.Node}
     */
    NodeList.prototype.head = null;


    /**
     * The last item in the node list, or null if the list contains no nodes.
     * @type {ash.core.Node}
     */

    NodeList.prototype.tail = null;


    /**
     * A signal that is dispatched whenever a node is added to the node list.
     *
     * <p>The signal will pass a single parameter to the listeners - the node that was added.</p>
     * @type {ash.signals.Signal1}
     */

    NodeList.prototype.nodeAdded = null;


    /**
     * A signal that is dispatched whenever a node is removed from the node list.
     *
     * <p>The signal will pass a single parameter to the listeners - the node that was removed.</p>
     * @type {ash.signals.Signal1}
     */

    NodeList.prototype.nodeRemoved = null;


    /**
     * @constructor
     */

    function NodeList() {
      this.nodeAdded = new Signal1();
      this.nodeRemoved = new Signal1();
    }


    /**
     * @param {ash.core.Node} node to add
     */

    NodeList.prototype.add = function(node) {
      if (!this.head) {
        this.head = this.tail = node;
        node.next = node.previous = null;
      } else {
        this.tail.next = node;
        node.previous = this.tail;
        node.next = null;
        this.tail = node;
      }
      this.nodeAdded.dispatch(node);
    };


    /**
     * @param {ash.core.Node} node to remove
     */

    NodeList.prototype.remove = function(node) {
      if (this.head === node) {
        this.head = this.head.next;
      }
      if (this.tail === node) {
        this.tail = this.tail.previous;
      }
      if (node.previous) {
        node.previous.next = node.next;
      }
      if (node.next) {
        node.next.previous = node.previous;
      }
      this.nodeRemoved.dispatch(node);
    };


    /**
     * remove all nodes
     */

    NodeList.prototype.removeAll = function() {
      var node;
      while (this.head) {
        node = this.head;
        this.head = this.head.next;
        node.previous = null;
        node.next = null;
        this.nodeRemoved.dispatch(node);
      }
      this.tail = null;
    };


    /**
     * true if the list is empty, false otherwise.
     * @type {boolean}
     */

    NodeList.prototype.isEmpty = function() {
      return this.head === null;
    };


    /**
     * Swaps the positions of two nodes in the list. Useful when sorting a list.
     *
     * @private
     */

    NodeList.prototype.swap = function(node1, node2) {
      var temp;
      if (node1.previous === node2) {
        node1.previous = node2.previous;
        node2.previous = node1;
        node2.next = node1.next;
        node1.next = node2;
      } else if (node2.previous === node1) {
        node2.previous = node1.previous;
        node1.previous = node2;
        node1.next = node2.next;
        node2.next = node1;
      } else {
        temp = node1.previous;
        node1.previous = node2.previous;
        node2.previous = temp;
        temp = node1.next;
        node1.next = node2.next;
        node2.next = temp;
      }
      if (this.head === node1) {
        this.head = node2;
      } else if (this.head === node2) {
        this.head = node1;
      }
      if (this.tail === node1) {
        this.tail = node2;
      } else if (this.tail === node2) {
        this.tail = node1;
      }
      if (node1.previous !== null) {
        node1.previous.next = node1;
      }
      if (node2.previous !== null) {
        node2.previous.next = node2;
      }
      if (node1.next !== null) {
        node1.next.previous = node1;
      }
      if (node2.next !== null) {
        node2.next.previous = node2;
      }
    };


    /**
     * Performs an insertion sort on the node list. In general, insertion sort is very efficient with short lists
     * and with lists that are mostly sorted, but is inefficient with large lists that are randomly ordered.
     *
     * <p>The sort function takes two nodes and returns an Int.</p>
     *
     * <p><code>function sortFunction( node1 : MockNode, node2 : MockNode ) : Int</code></p>
     *
     * <p>If the returned number is less than zero, the first node should be before the second. If it is greater
     * than zero the second node should be before the first. If it is zero the order of the nodes doesn't matter
     * and the original order will be retained.</p>
     *
     * <p>This insertion sort implementation runs in place so no objects are created during the sort.</p>
     *
     * @private
     * @param {Function} sort function
     */

    NodeList.prototype.insertionSort = function(sortFunction) {
      var node, other, remains;
      if (this.head === this.tail) {
        return;
      }
      remains = this.head.next;
      node = remains;
      while (node !== null) {
        remains = node.next;
        other = node.previous;
        while (other !== null) {
          if (sortFunction(node, other) >= 0) {
            if (node !== other.next) {
              if (this.tail === node) {
                this.tail = node.previous;
              }
              node.previous.next = node.next;
              if (node.next !== null) {
                node.next.previous = node.previous;
              }
              node.next = other.next;
              node.previous = other;
              node.next.previous = node;
              other.next = node;
            }
            break;
          }
          other = other.previous;
        }
        if (other === null) {
          if (this.tail === node) {
            this.tail = node.previous;
          }
          node.previous.next = node.next;
          if (node.next !== null) {
            node.next.previous = node.previous;
          }
          node.next = this.head;
          this.head.previous = node;
          node.previous = null;
          this.head = node;
        }
        node = remains;
      }
    };


    /*
     * Performs a merge sort on the node list. In general, merge sort is more efficient than insertion sort
     * with long lists that are very unsorted.
     *
     * <p>The sort function takes two nodes and returns an Int.</p>
     *
     * <p><code>function sortFunction( node1 : MockNode, node2 : MockNode ) : Int</code></p>
     *
     * <p>If the returned number is less than zero, the first node should be before the second. If it is greater
     * than zero the second node should be before the first. If it is zero the order of the nodes doesn't matter.</p>
     *
     * <p>This merge sort implementation creates and uses a single Vector during the sort operation.</p>
     *
     * @private
     * @param {Function} sort function
     */

    NodeList.prototype.mergeSort = function(sortFunction) {
      var end, lists, next, start;
      if (this.head === this.tail) {
        return;
      }
      lists = [];
      start = this.head;
      while (start !== null) {
        end = start;
        while (end.next !== null && sortFunction(end, end.next) <= 0) {
          end = end.next;
        }
        next = end.next;
        start.previous = end.next = null;
        lists.push(start);
        start = next;
      }
      while (lists.length > 1) {
        lists.push(this.merge(lists.shift(), lists.shift(), sortFunction));
      }
      this.tail = this.head = lists[0];
      while (this.tail.next !== null) {
        this.tail = this.tail.next;
      }
    };


    /*
     *
     * @private
     * @param {ash.core.Node} head1
     * @param {ash.core.Node} head2
     * @param {Function} sort function
     */

    NodeList.prototype.merge = function(head1, head2, sortFunction) {
      var head, node;
      if (sortFunction(head1, head2) <= 0) {
        head = node = head1;
        head1 = head1.next;
      } else {
        head = node = head2;
        head2 = head2.next;
      }
      while (head1 !== null && head2 !== null) {
        if (sortFunction(head1, head2) <= 0) {
          node.next = head1;
          head1.previous = node;
          node = head1;
          head1 = head1.next;
        } else {
          node.next = head2;
          head2.previous = node;
          node = head2;
          head2 = head2.next;
        }
      }
      if (head1 !== null) {
        node.next = head1;
        head1.previous = node;
      } else {
        node.next = head2;
        head2.previous = node;
      }
      return head;
    };

    return NodeList;

  })();


  /*
   * This internal class maintains a pool of deleted nodes for reuse by the framework. This reduces the overhead
   * from object creation and garbage collection.
   *
   * Because nodes may be deleted from a NodeList while in use, by deleting Nodes from a NodeList
   * while iterating through the NodeList, the pool also maintains a cache of nodes that are added to the pool
   * but should not be reused yet. They are then released into the pool by calling the releaseCache method.
   */

  'use strict';

  ash.core.NodePool = (function() {

    /**
     * @type {ash.core.Node}
     */
    NodePool.prototype.tail = null;


    /**
     * @type {Function}
     */

    NodePool.prototype.nodeClass = null;


    /**
     * @type {ash.core.Node}
     */

    NodePool.prototype.cacheTail = null;


    /**
     * @type {ash.ext.Dictionary}
     */

    NodePool.prototype.components = null;


    /**
     * Creates a pool for the given node class.
     * 
     * @constructor
     * @param {Function} nodeClass
     * @param {ash.core.Dictionary}
     */

    function NodePool(_at_nodeClass, _at_components) {
      this.nodeClass = _at_nodeClass;
      this.components = _at_components;
    }


    /**
     * Fetches a node from the pool.
     * @return {ash.core.Node}
     */

    NodePool.prototype.get = function() {
      var node;
      if (this.tail) {
        node = this.tail;
        this.tail = this.tail.previous;
        node.previous = null;
        return node;
      } else {
        node = new this.nodeClass();
        return node;
      }
    };


    /**
     * dispose of a node
     * @param {ash.core.Node}
     */

    NodePool.prototype.dispose = function(node) {
      var componentName;
      for (componentName in this.components) {
        node[componentName] = null;
      }
      node.entity = null;
      node.next = null;
      node.previous = this.tail;
      this.tail = node;
    };


    /**
     * Adds a node to the cache
     * @param {ash.core.Node}
     */

    NodePool.prototype.cache = function(node) {
      node.previous = this.cacheTail;
      this.cacheTail = node;
    };


    /**
     * Releases all nodes from the cache into the pool
     */

    NodePool.prototype.releaseCache = function() {
      var node;
      while (this.cacheTail) {
        node = this.cacheTail;
        this.cacheTail = node.previous;
        this.dispose(node);
      }
    };

    return NodePool;

  })();


  /*
   * The base class for a system.
   *
   * <p>A system is part of the core functionality of the game. After a system is added to the engine, its
   * update method will be called on every frame of the engine. When the system is removed from the engine,
   * the update method is no longer called.</p>
   *
   * <p>The aggregate of all systems in the engine is the functionality of the game, with the update
   * methods of those systems collectively constituting the engine update loop. Systems generally operate on
   * node lists - collections of nodes. Each node contains the components from an entity in the engine
   * that match the node.</p>
   */

  'use strict';


  /*
   * @constructor
   */

  ash.core.System = (function() {
    function System() {}


    /**
      * Used internally to manage the list of systems within the engine. The previous system in the list.
      * @type {ash.core.System}
     */

    System.prototype.previous = null;


    /**
     * Used internally to manage the list of systems within the engine. The next system in the list.
     * @type {ash.core.System}
     */

    System.prototype.next = null;


    /*
     * Used internally to hold the priority of this system within the system list. This is
     * used to order the systems so they are updated in the correct order.
     * @type {number}
     */

    System.prototype.priority = 0;


    /*
     * Called just after the system is added to the engine, before any calls to the update method.
     * Override this method to add your own functionality.
     *
     * @param {ash.core.Engine} engine The engine the system was added to.
     */

    System.prototype.addToEngine = function(engine) {};


    /*
     * Called just after the system is removed from the engine, after all calls to the update method.
     * Override this method to add your own functionality.
     *
     * @param {ash.core.Engine} engine The engine the system was removed from.
     */

    System.prototype.removeFromEngine = function(engine) {};


    /*
     * After the system is added to the engine, this method is called every frame until the system
     * is removed from the engine. Override this method to add your own functionality.
     *
     * <p>If you need to perform an action outside of the update loop (e.g. you need to change the
     * systems in the engine and you don't want to do it while they're updating) add a listener to
     * the engine's updateComplete signal to be notified when the update loop completes.</p>
     *
     * @param {number} time The duration, in seconds, of the frame.
     */

    System.prototype.update = function(time) {};

    return System;

  })();


  /*
   * Used internally, this is an ordered list of Systems for use by the engine update loop.
   */

  'use strict';


  /*
   * @constructor
   */

  ash.core.SystemList = (function() {
    function SystemList() {}


    /**
     * @type {ash.core.System}
     */

    SystemList.prototype.head = null;


    /**
     * @type {ash.core.System}
     */

    SystemList.prototype.tail = null;


    /**
     * Add system
     * @param {ash.core.System}
     */

    SystemList.prototype.add = function(system) {
      var node;
      if (!this.head) {
        this.head = this.tail = system;
        system.next = system.previous = null;
      } else {
        node = this.tail;
        while (node) {
          if (node.priority <= system.priority) {
            break;
          }
          node = node.previous;
        }
        if (node === this.tail) {
          this.tail.next = system;
          system.previous = this.tail;
          system.next = null;
          this.tail = system;
        } else if (!node) {
          system.next = this.head;
          system.previous = null;
          this.head.previous = system;
          this.head = system;
        } else {
          system.next = node.next;
          system.previous = node;
          node.next.previous = system;
          node.next = system;
        }
      }
    };


    /**
     * remove system
     * @param {ash.core.System}
     */

    SystemList.prototype.remove = function(system) {
      if (this.head === system) {
        this.head = this.head.next;
      }
      if (this.tail === system) {
        this.tail = this.tail.previous;
      }
      if (system.previous) {
        system.previous.next = system.next;
      }
      if (system.next) {
        system.next.previous = system.previous;
      }
    };


    /**
     * Remove all systems
     */

    SystemList.prototype.removeAll = function() {
      var system;
      while (this.head) {
        system = this.head;
        this.head = this.head.next;
        system.previous = null;
        system.next = null;
      }
      this.tail = null;
    };


    /**
     * Get system for class
     * @param {Function}
     * @return {ash.core.System}
     */

    SystemList.prototype.get = function(type) {
      var system;
      system = this.head;
      while (system) {
        if (system.constructor === type) {
          return system;
        }
        system = system.next;
      }
      return null;
    };

    return SystemList;

  })();


  /*
   * The interface for classes that are used to manage NodeLists (set as the familyClass property
   * in the Engine object). Most developers don't need to use this since the default implementation
   * is used by default and suits most needs.
   */

  'use strict';


  /**
    * @interface
   */

  ash.core.Family = (function() {
    function Family() {}


    /**
     * Returns the NodeList managed by this class. This should be a reference that remains valid always
     * since it is retained and reused by Systems that use the list. i.e. never recreate the list,
     * always modify it in place.
     * @type {ash.core.NodeList}
     */

    Family.prototype.nodes = null;


    /**
     * An entity has been added to the engine. It may already have components so test the entity
     * for inclusion in this family's NodeList.
     * 
     * @param {ash.core.Entity} entity that was added
     */

    Family.prototype.newEntity = function(entity) {
      throw new Error('Method must be overriden');
    };


    /**
     * An entity has been removed from the engine. If it's in this family's NodeList it should be removed.
     *
     * @param {ash.core.Entity} entity to remove
     */

    Family.prototype.removeEntity = function(entity) {
      throw new Error('Method must be overriden');
    };


    /**
     * A component has been added to an entity. Test whether the entity's inclusion in this family's
     * NodeList should be modified.
     *
     * @param {ash.core.Entity} entity with component that was added
     * @param {Object} componentClass that was added
     */

    Family.prototype.componentAddedToEntity = function(entity, componentClass) {
      throw new Error('Method must be overriden');
    };


    /**
     * A component has been removed from an entity. Test whether the entity's inclusion in this family's
     * NodeList should be modified.
     *
     * @param {ash.core.Entity} entity with component that was removed
     * @param {Object} componentClass that was removed
     */

    Family.prototype.componentRemovedFromEntity = function(entity, componentClass) {
      throw new Error('Method must be overriden');
    };


    /**
     * The family is about to be discarded. Clean up all properties as necessary. Usually, you will
     * want to empty the NodeList at this time.
     */

    Family.prototype.cleanUp = function() {
      throw new Error('Method must be overriden');
    };

    return Family;

  })();


  /*
   * The default class for managing a NodeList. This class creates the NodeList and adds and removes
   * nodes to/from the list as the entities and the components in the engine change.
   *
   * It uses the basic entity matching pattern of an entity system - entities are added to the list if
   * they contain components matching all the public properties of the node class.
   */

  'use strict';

  EntityList = ash.core.EntityList;

  Dictionary = ash.ext.Dictionary;

  NodeList = ash.core.NodeList;

  NodePool = ash.core.NodePool;

  Util = ash.ext.Util;

  ash.core.ComponentMatchingFamily = (function() {

    /**
     * The nodelist managed by this family. This is a reference that remains valid always
     * since it is retained and reused by Systems that use the list. i.e. we never recreate the list,
     * we always modify it in place.
     * @type {ash.core.NodeList}
     */
    ComponentMatchingFamily.prototype.nodes = null;


    /**
     * @type {ash.ext.Dictionary}
     */

    ComponentMatchingFamily.prototype.entities = null;


    /**
     * @type {Function}
     */

    ComponentMatchingFamily.prototype.nodeClass = null;


    /**
     * @type {ash.ext.Dictionary}
     */

    ComponentMatchingFamily.prototype.components = null;


    /**
     * @type {ash.core.NodePool}
     */

    ComponentMatchingFamily.prototype.nodePool = null;


    /**
     * @type {ash.core.Engine}
     */

    ComponentMatchingFamily.prototype.engine = null;


    /**
     * The constructor. Creates a ComponentMatchingFamily to provide a NodeList for the
     * given node class.
     *
     * @constructor
     * @implements {ash.core.Family}
     *
     * @param {Object} nodeClass The type of node to create and manage a NodeList for.
     * @param {ash.core.Engine} engine The engine that this family is managing teh NodeList for.
     */

    function ComponentMatchingFamily(_at_nodeClass, _at_engine) {
      this.nodeClass = _at_nodeClass;
      this.engine = _at_engine;
      this.releaseNodePoolCache = __bind(this.releaseNodePoolCache, this);
      this.init();
    }


    /**
     * Initialises the class. Creates the nodelist and other tools. Analyses the node to determine
     * what component types the node requires.
     * @private
     */

    ComponentMatchingFamily.prototype.init = function() {
      var name, type, _ref;
      this.nodes = new NodeList();
      this.entities = new Dictionary();
      this.components = new Dictionary();
      this.nodePool = new NodePool(this.nodeClass, this.nodeClass.components);
      _ref = this.nodeClass.components;
      for (name in _ref) {
        type = _ref[name];
        this.components[Util.getClassName(type)] = type;
      }
    };


    /**
     * Called by the engine when an entity has been added to it. We check if the entity should be in
     * this family's NodeList and add it if appropriate.
     *
     * @param {ash.core.Entity} entity that was added
     */

    ComponentMatchingFamily.prototype.newEntity = function(entity) {
      this.addIfMatch(entity);
    };


    /**
     * Called by the engine when a component has been added to an entity. We check if the entity is not in
     * this family's NodeList and should be, and add it if appropriate.
     *
     * @param {ash.core.Entity} entity with component that was added
     * @param {Object} componentClass that was added
     */

    ComponentMatchingFamily.prototype.componentAddedToEntity = function(entity, componentClass) {
      this.addIfMatch(entity);
    };


    /**
     * Called by the engine when a component has been removed from an entity. We check if the removed component
     * is required by this family's NodeList and if so, we check if the entity is in this this NodeList and
     * remove it if so.
     *
     * @param {ash.core.Entity} entity with component that was removed
     * @param {Object} componentClass that was removed
     */

    ComponentMatchingFamily.prototype.componentRemovedFromEntity = function(entity, componentClass) {
      var name;
      name = Util.getClassName(componentClass) != null ? Util.getClassName(componentClass) : componentClass;
      if (name in this.components) {
        this.removeIfMatch(entity);
      }
    };


    /**
     * Called by the engine when an entity has been rmoved from it. We check if the entity is in
     * this family's NodeList and remove it if so.
     *
     * @param {ash.core.Entity} entity to remove
     */

    ComponentMatchingFamily.prototype.removeEntity = function(entity) {
      this.removeIfMatch(entity);
    };


    /**
     * If the entity is not in this family's NodeList, tests the components of the entity to see
     * if it should be in this NodeList and adds it if so.
     *
     * @param {ash.core.Entity} entity to check
     */

    ComponentMatchingFamily.prototype.addIfMatch = function(entity) {
      var componentClass, name, node, _ref, _ref1;
      if (this.entities[entity.name] == null) {
        _ref = this.nodeClass.components;
        for (name in _ref) {
          componentClass = _ref[name];
          if (!entity.has(componentClass)) {
            return;
          }
        }
        node = this.nodePool.get();
        node.entity = entity;
        _ref1 = this.nodeClass.components;
        for (name in _ref1) {
          componentClass = _ref1[name];
          node[name] = entity.get(componentClass);
        }
        this.entities[entity.name] = node;
        this.nodes.add(node);
      }
    };


    /**
     * Removes the entity if it is in this family's NodeList.
     *
     * @param {ash.core.Entity} entity to check
     */

    ComponentMatchingFamily.prototype.removeIfMatch = function(entity) {
      var node;
      if (entity.name in this.entities) {
        node = this.entities[entity.name];
        delete this.entities[entity.name];
        this.nodes.remove(node);
        if (this.engine.updating) {
          this.nodePool.cache(node);
          this.engine.updateComplete.add(this.releaseNodePoolCache);
        } else {
          this.nodePool.dispose(node);
        }
      }
    };


    /**
     * Releases the nodes that were added to the node pool during this engine update, so they can
     * be reused.
     */

    ComponentMatchingFamily.prototype.releaseNodePoolCache = function() {
      this.engine.updateComplete.remove(this.releaseNodePoolCache);
      this.nodePool.releaseCache();
    };


    /**
     * Removes all nodes from the NodeList.
     */

    ComponentMatchingFamily.prototype.cleanUp = function() {
      var node;
      node = this.nodes.head;
      while (node) {
        this.entities.remove(node.entity);
        node = node.next;
      }
      this.nodes.removeAll();
    };

    return ComponentMatchingFamily;

  })();


  /*
   * The Engine class is the central point for creating and managing your game state. Add
   * entities and systems to the engine, and fetch families of nodes from the engine.
   */

  'use strict';

  EntityList = ash.core.EntityList;

  Dictionary = ash.ext.Dictionary;

  SystemList = ash.core.SystemList;

  Signal0 = ash.signals.Signal0;

  Util = ash.ext.Util;

  ComponentMatchingFamily = ash.core.ComponentMatchingFamily;

  ash.core.Engine = (function() {

    /**
     * @type {ash.ext.Dictionary}
     */
    Engine.prototype.entityNames = null;


    /**
     * @type {ash.core.EntityList}
     */

    Engine.prototype.entityList = null;


    /**
     * @type {ash.core.SystemList}
     */

    Engine.prototype.systemList = null;


    /**
     * @type {ash.ext.Dictionary}
     */

    Engine.prototype.families = null;


    /**
     * Indicates if the engine is currently in its update loop.
     *
     * @type {boolean}
     */

    Engine.prototype.updating = false;


    /**
     * Dispatched when the update loop ends. If you want to add and remove systems from the
     * engine it is usually best not to do so during the update loop. To avoid this you can
     * listen for this signal and make the change when the signal is dispatched.
     *
     * @type {ash.signals.Signal0}
     */

    Engine.prototype.updateComplete = null;


    /**
     * The class used to manage node lists. In most cases the default class is sufficient
     * but it is exposed here so advanced developers can choose to create and use a
     * different implementation.
     *
     * The class must implement the IFamily interface.
     * @type {Function}
     */

    Engine.prototype.familyClass = ash.core.ComponentMatchingFamily;


    /**
     * @constructor
     */

    function Engine() {
      this.update = __bind(this.update, this);
      this.componentRemoved = __bind(this.componentRemoved, this);
      this.componentAdded = __bind(this.componentAdded, this);
      this.entityNameChanged = __bind(this.entityNameChanged, this);
      this.entityList = new EntityList();
      this.entityNames = new Dictionary();
      this.systemList = new SystemList();
      this.families = new Dictionary();
      this.updateComplete = new Signal0();
    }


    /*
     * Returns a vector containing all the entities in the engine.
     */

    Engine.prototype.getEntities = function() {
      var entities, entity;
      entities = [];
      entity = this.entityList.head;
      while (entity) {
        this.entities.push(entity);
        entity = entity.next;
      }
      return entities;
    };


    /*
     * Returns a vector containing all the systems in the engine.
     */

    Engine.prototype.getSystems = function() {
      var system, systems;
      systems = [];
      system = this.systemList.head;
      while (system) {
        systems.push(system);
        system = system.next;
      }
      return systems;
    };


    /**
     * Add an entity to the engine.
     *
     * @param {ash.core.Entity} entity The entity to add.
     */

    Engine.prototype.addEntity = function(entity) {
      var each, family, _ref;
      if (this.entityNames[entity.name]) {
        throw "The entity name " + entity.name + " is already in use by another entity.";
      }
      this.entityList.add(entity);
      this.entityNames[entity.name] = entity;
      entity.componentAdded.add(this.componentAdded);
      entity.componentRemoved.add(this.componentRemoved);
      entity.nameChanged.add(this.entityNameChanged);
      _ref = this.families;
      for (each in _ref) {
        family = _ref[each];
        family.newEntity(entity);
      }
    };


    /**
     * Remove an entity from the engine.
     *
     * @param {ash.core.Entity} entity The entity to remove.
     */

    Engine.prototype.removeEntity = function(entity) {
      var each, family, _ref;
      entity.componentAdded.remove(this.componentAdded);
      entity.componentRemoved.remove(this.componentRemoved);
      entity.nameChanged.remove(this.entityNameChanged);
      _ref = this.families;
      for (each in _ref) {
        family = _ref[each];
        family.removeEntity(entity);
      }
      delete this.entityNames[entity.name];
      this.entityList.remove(entity);
    };


    /**
     * Entity Name Changed
     *
     * @param {ash.core.Entity} entity The entity that Changed
     * @param {string} name the old name
     */

    Engine.prototype.entityNameChanged = function(entity, oldName) {
      if (this.entityNames[oldName] === entity) {
        delete this.entityNames[oldName];
        this.entityNames[entity.name] = entity;
      }
    };


    /**
     * Get an entity based n its name.
     *
     * @param {string} name The name of the entity
     * @return {ash.core.Entity} The entity, or null if no entity with that name exists on the engine
     */

    Engine.prototype.getEntityByName = function(name) {
      return this.entityNames[name];
    };


    /**
     * Remove all entities from the engine.
     */

    Engine.prototype.removeAllEntities = function() {
      while (this.entityList.head !== null) {
        this.removeEntity(this.entityList.head);
      }
    };


    /**
     * @private
     * @param {ash.core.Entity} entity The entity that Changed
     * @param {Object} componentClass the class object
     */

    Engine.prototype.componentAdded = function(entity, componentClass) {
      var each, family, _ref;
      _ref = this.families;
      for (each in _ref) {
        family = _ref[each];
        family.componentAddedToEntity(entity, componentClass);
      }
    };


    /**
     * @private
     * @param {ash.core.Entity} entity The entity that Changed
     * @param {Object} componentClass the class object
     */

    Engine.prototype.componentRemoved = function(entity, componentClass) {
      var each, family, _ref;
      _ref = this.families;
      for (each in _ref) {
        family = _ref[each];
        family.componentRemovedFromEntity(entity, componentClass);
      }
    };


    /**
     * Get a collection of nodes from the engine, based on the type of the node required.
     *
     * <p>The engine will create the appropriate NodeList if it doesn't already exist and
     * will keep its contents up to date as entities are added to and removed from the
     * engine.</p>
     *
     * <p>If a NodeList is no longer required, release it with the releaseNodeList method.</p>
     *
     * @param {Object} nodeClass The type of node required.
     * @return {ash.core.NodeList} A linked list of all nodes of this type from all entities in the engine.
     */

    Engine.prototype.getNodeList = function(nodeClass) {
      var entity, family;
      if (Util.getClassName(nodeClass) in this.families) {
        return this.families[Util.getClassName(nodeClass)].nodes;
      }
      family = new this.familyClass(nodeClass, this);
      this.families[Util.getClassName(nodeClass)] = family;
      entity = this.entityList.head;
      while (entity) {
        family.newEntity(entity);
        entity = entity.next;
      }
      return family.nodes;
    };


    /**
     * If a NodeList is no longer required, this method will stop the engine updating
     * the list and will release all references to the list within the framework
     * classes, enabling it to be garbage collected.
     *
     * <p>It is not essential to release a list, but releasing it will free
     * up memory and processor resources.</p>
     *
     * @param {Object} nodeClass The type of the node class if the list to be released.
     */

    Engine.prototype.releaseNodeList = function(nodeClass) {
      if (Util.getClassName(nodeClass) in this.families) {
        this.families[Util.getClassName(nodeClass)].cleanUp();
        delete this.families[Util.getClassName(nodeClass)];
      }
    };


    /**
     * Add a system to the engine, and set its priority for the order in which the
     * systems are updated by the engine update loop.
     *
     * <p>The priority dictates the order in which the systems are updated by the engine update
     * loop. Lower numbers for priority are updated first. i.e. a priority of 1 is
     * updated before a priority of 2.</p>
     *
     * @param {ash.core.System} system The system to add to the engine.
     * @param {number} priority The priority for updating the systems during the engine loop. A
     * lower number means the system is updated sooner.
     */

    Engine.prototype.addSystem = function(system, priority) {
      system.priority = priority;
      system.addToEngine(this);
      this.systemList.add(system);
    };


    /**
     * Get the system instance of a particular type from within the engine.
     *
     * @param {Object} type The type of system
     * @return {ash.core.System} The instance of the system type that is in the engine, or
     * null if no systems of this type are in the engine.
     */

    Engine.prototype.getSystem = function(type) {
      return this.systemList.get(type);
    };


    /**
     * Remove a system from the engine.
     *
     * @param {ash.core.System} system The system to remove from the engine.
     */

    Engine.prototype.removeSystem = function(system) {
      this.systemList.remove(system);
      system.removeFromEngine(this);
    };


    /**
     * Remove all systems from the engine.
     */

    Engine.prototype.removeAllSystems = function() {
      while (this.systemList.head !== null) {
        this.removeSystem(this.systemList.head);
      }
    };


    /**
     * Update the engine. This causes the engine update loop to run, calling update on all the
     * systems in the engine.
     *
     * <p>The package ash.tick contains classes that can be used to provide
     * a steady or variable tick that calls this update method.</p>
     *
     * @time {number} The duration, in seconds, of this update step.
     */

    Engine.prototype.update = function(time) {
      var system;
      this.updating = true;
      system = this.systemList.head;
      while (system) {
        system.update(time);
        system = system.next;
      }
      this.updating = false;
      this.updateComplete.dispatch();
    };

    return Engine;

  })();


  /*
   * A Helper for Components & Nodes
   *
   * Creates a common registry object
   * Fix-up up Node templates
   */

  'use strict';


  /**
   * @constructor
   * @dict
   */

  ash.ext.Dictionary = (function() {
    function Dictionary() {}

    return Dictionary;

  })();


  /*
   * A Helper for Components & Nodes
   *
   * Creates a common registry object
   * Fix-up up Node templates
   */

  'use strict';

  ash.ext.Helper = (function() {

    /**
     * @type {Object}
     */
    Helper.prototype.components = null;


    /**
     * @type {Object}
     */

    Helper.prototype.nodes = null;


    /**
     * @constructor
     * @param {Object} components
     * @param {Object} nodes
     */

    function Helper(components, nodes) {
      var klass, name, property, type, _ref;
      this.components = {};
      this.nodes = {};

      /*
       * register components
       */
      if (components != null) {
        for (name in components) {
          klass = components[name];
          this.components[name] = klass;
        }
      }

      /*
       * register nodes
       */
      if (nodes != null) {
        for (name in nodes) {
          klass = nodes[name];

          /*
           * convert template to an actual node class
           */
          if (klass.components == null) {
            klass.components = {};
            _ref = klass.prototype;
            for (property in _ref) {
              type = _ref[property];
              klass.components[property] = type;
              klass.prototype[property] = null;
            }
            klass.prototype.entity = null;
            klass.prototype.previous = null;
            klass.prototype.next = null;
          }
          if (components != null) {
            this.nodes[name] = klass;
          }
        }
      }
    }

    return Helper;

  })();


  /**
   * @constructor
   */

  ash.ext.Util = (function() {
    function Util() {}


    /**
    	 * Get Class Name
    	 *
    	 * closure compiler changes the class name, or sets it to ''
    	 * In that case, add a static className property to all
    	 * Nodes and Components so they can be identified.
    	 *
    	 * @param {Function} klass
    	 * @return {string}
     */

    Util.getClassName = function(klass) {
      var _ref;
      return (_ref = klass.className) != null ? _ref : klass.name;
    };

    return Util;

  })();


  /*
   * This component provider always returns the same instance of the component. The instance
   * is passed to the provider at initialisation.
   */

  'use strict';

  ash.fsm.ComponentInstanceProvider = (function() {

    /**
     * @type {Object}
     */
    ComponentInstanceProvider.prototype.instance = null;


    /**
     * @constructor
     * @param {Object} instance The instance to return whenever a component is requested.
     */

    function ComponentInstanceProvider(_at_instance) {
      this.instance = _at_instance;
    }


    /**
     * Used to request a component from this provider
     *
     * @return {Object} The instance
     */

    ComponentInstanceProvider.prototype.getComponent = function() {
      return this.instance;
    };


    /**
     * Used to compare this provider with others. Any provider that returns the same component
     * instance will be regarded as equivalent.
     *
     * @return {Object} The instance
     */

    ComponentInstanceProvider.prototype.getIdentifier = function() {
      return this.instance;
    };

    return ComponentInstanceProvider;

  })();

  'use strict';

  ash.fsm.ComponentSingletonProvider = (function() {

    /**
     * @type {Function}
     */
    ComponentSingletonProvider.prototype.componentType = null;


    /**
     * @type {Object}
     */

    ComponentSingletonProvider.prototype.instance = null;


    /**
     * @constructor
     * @param {Function} type The type of the single instance
     */

    function ComponentSingletonProvider(type) {
      this.componentType = type;
    }


    /**
      * Used to request a component from this provider
      *
      * @return {Object} The instance
     */

    ComponentSingletonProvider.prototype.getComponent = function() {
      if (this.instance == null) {
        this.instance = new this.componentType();
      }
      return this.instance;
    };


    /**
     * Used to compare this provider with others. Any provider that returns the same component
     * instance will be regarded as equivalent.
     *
     * @return {Object} The instance
     */

    ComponentSingletonProvider.prototype.getIdentifier = function() {
      return this.getComponent();
    };

    return ComponentSingletonProvider;

  })();

  'use strict';

  ash.fsm.ComponentTypeProvider = (function() {

    /**
     * @type {Function}
     */
    ComponentTypeProvider.prototype.componentType = null;


    /**
     * @constructor
     * @param {Function} type The type of the single instance
     */

    function ComponentTypeProvider(type) {
      this.componentType = type;
    }


    /**
     * Used to request a component from this provider
     *
     * @return {Object} The instance
     */

    ComponentTypeProvider.prototype.getComponent = function() {
      return new this.componentType();
    };


    /**
     * Used to compare this provider with others. Any provider that returns the same component
     * instance will be regarded as equivalent.
     *
     * @return {Object} The instance
     */

    ComponentTypeProvider.prototype.getIdentifier = function() {
      return this.componentType;
    };

    return ComponentTypeProvider;

  })();

  'use strict';

  ash.fsm.DynamicComponentProvider = (function() {

    /**
     * @type {Object}
     */
    DynamicComponentProvider.prototype._closure = null;


    /**
     * @constructor
     * @param {Object} closure The function that will return the component instance when called.
     */

    function DynamicComponentProvider(closure) {
      this._closure = closure;
    }


    /**
      * Used to request a component from this provider
      *
      * @return {Object} The instance
     */

    DynamicComponentProvider.prototype.getComponent = function() {
      return this._closure;
    };


    /**
     * Used to compare this provider with others. Any provider that returns the same component
     * instance will be regarded as equivalent.
     *
     * @return {Object} The instance
     */

    DynamicComponentProvider.prototype.getIdentifier = function() {
      return this._closure;
    };

    return DynamicComponentProvider;

  })();


  /*
   * This System provider returns results of a method call. The method
   * is passed to the provider at initialisation.
   */

  'use strict';

  ash.fsm.DynamicSystemProvider = (function() {

    /**
     * @type {Function}
     */
    DynamicSystemProvider.prototype.method = function() {};


    /**
     * The priority at which the System should be added to the Engine
     * @type {number}
     */

    DynamicSystemProvider.prototype.priority = 0;


    /**
     * @constructor
     * @param {Function} method The method that returns the System instance;
     */

    function DynamicSystemProvider(_at_method) {
      this.method = _at_method;
    }


    /*
     * Used to compare this provider with others. Any provider that returns the same component
     * instance will be regarded as equivalent.
     *
     * @return {Function} The method used to call the System instances
     */

    DynamicSystemProvider.prototype.getSystem = function() {
      return this.method();
    };


    /*
     * The priority at which the System should be added to the Engine
     * @return {Function}
     */

    DynamicSystemProvider.prototype.getIdentifier = function() {
      return this.method;
    };

    return DynamicSystemProvider;

  })();


  /*
   * Represents a state for a SystemStateMachine. The state contains any number of SystemProviders which
   * are used to add Systems to the Engine when this state is entered.
   */

  'use strict';

  SystemInstanceProvider = ash.fsm.SystemInstanceProvider;

  SystemSingletonProvider = ash.fsm.SystemSingletonProvider;

  DynamicSystemProvider = ash.fsm.DynamicSystemProvider;

  StateSystemMapping = ash.fsm.StateSystemMapping;

  ash.fsm.EngineState = (function() {

    /**
     * @type {Array<Object>}
     */
    EngineState.prototype.providers = null;


    /**
     * @constructor
     */

    function EngineState() {
      this.providers = [];
    }


    /**
     * Creates a mapping for the System type to a specific System instance. A
     * SystemInstanceProvider is used for the mapping.
     *
     * @param {ash.core.System} system The System instance to use for the mapping
     * @return {ash.fsm.StateSystemMapping} This StateSystemMapping, so more modifications can be applied
     */

    EngineState.prototype.addInstance = function(system) {
      return this.addProvider(new SystemInstanceProvider(system));
    };


    /**
     * Creates a mapping for the System type to a single instance of the provided type.
     * The instance is not created until it is first requested. The type should be the same
     * as or extend the type for this mapping. A SystemSingletonProvider is used for
     * the mapping.
     *
     * @param {Function} type The type of the single instance to be created. If omitted, the type of the
     * mapping is used.
     * @return {ash.fsm.StateSystemMapping} This StateSystemMapping, so more modifications can be applied
     */

    EngineState.prototype.addSingleton = function(type) {
      return this.addProvider(new SystemSingletonProvider(type));
    };


    /**
     * Creates a mapping for the System type to a method call.
     * The method should return a System instance. A DynamicSystemProvider is used for
     * the mapping.
     *
     * @param {Function} method The method to provide the System instance.
     * @return {ash.fsm.StateSystemMapping} This StateSystemMapping, so more modifications can be applied.
     */

    EngineState.prototype.addMethod = function(method) {
      return this.addProvider(new DynamicSystemProvider(method));
    };


    /**
     * Adds any SystemProvider.
     *
     * @param provider The component provider to use.
     * @return {ash.fsm.StateSystemMapping} This StateSystemMapping, so more modifications can be applied.
     */

    EngineState.prototype.addProvider = function(provider) {
      var mapping;
      mapping = new StateSystemMapping(this, provider);
      this.providers.push(provider);
      return mapping;
    };

    return EngineState;

  })();


  /*
   * Used by the EntityState class to create the mappings of components to providers via a fluent interface.
   */

  'use strict';

  ComponentInstanceProvider = ash.fsm.ComponentInstanceProvider;

  ComponentTypeProvider = ash.fsm.ComponentTypeProvider;

  ComponentSingletonProvider = ash.fsm.ComponentSingletonProvider;

  DynamicComponentProvider = ash.fsm.DynamicComponentProvider;

  ash.fsm.StateComponentMapping = (function() {

    /**
     * @type {Function}
     */
    StateComponentMapping.prototype.componentType = null;


    /**
     * @type {ash.fsm.EntityState}
     */

    StateComponentMapping.prototype.creatingState = null;


    /**
     * @type {Object}
     */

    StateComponentMapping.prototype.provider = null;


    /**
     * Used internally, the constructor creates a component mapping. The constructor
     * creates a ComponentTypeProvider as the default mapping, which will be replaced
     * by more specific mappings if other methods are called.
     *
     * @constructor
     * @param {ash.fsm.EntityState} creatingState The EntityState that the mapping will belong to
     * @param {Function} type The component type for the mapping
     */

    function StateComponentMapping(_at_creatingState, type) {
      this.creatingState = _at_creatingState;
      this.componentType = type;
      this.withType(type);
    }


    /**
     * Creates a mapping for the component type to a specific component instance. A
     * ComponentInstanceProvider is used for the mapping.
     *
     * @param {Object} component The component instance to use for the mapping
     * @return {ash.fsm.StateComponentMapping} This ComponentMapping, so more modifications can be applied
     */

    StateComponentMapping.prototype.withInstance = function(component) {
      this.setProvider(new ComponentInstanceProvider(component));
      return this;
    };


    /**
     * Creates a mapping for the component type to new instances of the provided type.
     * The type should be the same as or extend the type for this mapping. A ComponentTypeProvider
     * is used for the mapping.
     *
     * @param {Function} type The type of components to be created by this mapping
     * @return {ash.fsm.StateComponentMapping} This ComponentMapping, so more modifications can be applied
     */

    StateComponentMapping.prototype.withType = function(type) {
      this.setProvider(new ComponentTypeProvider(type));
      return this;
    };


    /**
     * Creates a mapping for the component type to a single instance of the provided type.
     * The instance is not created until it is first requested. The type should be the same
     * as or extend the type for this mapping. A ComponentSingletonProvider is used for
     * the mapping.
     *
     * @param {Function} The type of the single instance to be created. If omitted, the type of the
     * mapping is used.
     * @return {ash.fsm.StateComponentMapping} This ComponentMapping, so more modifications can be applied
     */

    StateComponentMapping.prototype.withSingleton = function(type) {
      if (type == null) {
        type = this.componentType;
      }
      this.setProvider(new ComponentSingletonProvider(type));
      return this;
    };


    /**
     * Creates a mapping for the component type to a method call. A
     * DynamicComponentProvider is used for the mapping.
     *
     * @param {Function} method The method to return the component instance
     * @return {ash.fsm.StateComponentMapping} This ComponentMapping, so more modifications can be applied
     */

    StateComponentMapping.prototype.withMethod = function(method) {
      this.setProvider(new DynamicComponentProvider(method));
      return this;
    };


    /** 
     * Creates a mapping for the component type to any ComponentProvider.
     *
     * @param {Object} provider The component provider to use.
     * @return {ash.fsm.StateComponentMapping} This ComponentMapping, so more modifications can be applied.
     */

    StateComponentMapping.prototype.withProvider = function(provider) {
      this.setProvider(provider);
      return this;
    };


    /**
     * Maps through to the add method of the EntityState that this mapping belongs to
     * so that a fluent interface can be used when configuring entity states.
     *
     * @param {Function} type The type of component to add a mapping to the state for
     * @return {ash.fsm.StateComponentMapping} The new ComponentMapping for that type
     */

    StateComponentMapping.prototype.add = function(type) {
      return this.creatingState.add(type);
    };


    /**
     * @param {Object} provider
     */

    StateComponentMapping.prototype.setProvider = function(provider) {
      this.provider = provider;
      return this.creatingState.providers[this.componentType] = provider;
    };

    return StateComponentMapping;

  })();


  /*
   * This is a state machine for the Engine. The state machine manages a set of states,
   * each of which has a set of System providers. When the state machine changes the state, it removes
   * Systems associated with the previous state and adds Systems associated with the new state.
   */

  'use strict';

  Dictionary = ash.ext.Dictionary;

  EngineState = ash.fsm.EngineState;

  ash.fsm.EngineStateMachine = (function() {

    /**
     * @type {ash.core.Engine}
     */
    EngineStateMachine.prototype.engine = null;


    /**
     * @type {ash.ext.Dictionary}
     */

    EngineStateMachine.prototype.states = null;


    /**
     * @type {ash.fsm.EngineState}
     */

    EngineStateMachine.prototype.currentState = null;


    /**
     * Creates an SystemStateMachine.
     * @constructor 
     * @param {ash.core.Engine} engine
     */

    function EngineStateMachine(_at_engine) {
      this.engine = _at_engine;
      this.states = new Dictionary();
    }


    /**
     * Add a state to this state machine.
     *
     * @param {string} name The name of this state - used to identify it later in the changeState method call.
     * @param {ash.fsm.EngineState} state The state.
     * @return {ash.fsm.EngineStateMachine} This state machine, so methods can be chained.
     */

    EngineStateMachine.prototype.addState = function(name, state) {
      this.states[name] = state;
      return this;
    };


    /**
     * Create a new state in this state machine.
     *
     * @param {string} name The name of the new state - used to identify it later in the changeState method call.
     * @return {ash.fsm.EngineState} The new EntityState object that is the state. This will need to be configured with
     * the appropriate component providers.
     */

    EngineStateMachine.prototype.createState = function(name) {
      var state;
      state = new EngineState();
      this.states[name] = state;
      return this;
    };


    /**
     * Change to a new state. The Systems from the old state will be removed and the Systems
     * for the new state will be added.
     *
     * @param {string} name The name of the state to change to.
     */

    EngineStateMachine.prototype.changeState = function(name) {
      var each, id, newState, other, provider, toAdd, _ref, _ref1;
      newState = this.states[name];
      if (newState == null) {
        throw new Error("Engine state " + name + " doesn't exist");
      }
      if (newState === this.currentState) {
        newState = null;
        return;
      }
      toAdd = new Dictionary();
      _ref = newState.providers;
      for (each in _ref) {
        provider = _ref[each];
        id = provider.getIdentifier();
        toAdd[id] = provider;
      }
      if (currentState) {
        _ref1 = this.currentState.providers;
        for (each in _ref1) {
          provider = _ref1[each];
          id = provider.getIdentifier();
          other = toAdd[id];
          if (other) {
            delete toAdd[id];
          } else {
            this.engine.removeSystem(provider.getSystem());
          }
        }
      }
      for (each in toAdd) {
        provider = toAdd[each];
        this.engine.addSystem(provider.getSystem(), provider.priority);
      }
      return this.currentState = newState;
    };

    return EngineStateMachine;

  })();


  /*
   * Represents a state for an EntityStateMachine. The state contains any number of ComponentProviders which
   * are used to add components to the entity when this state is entered.
   */

  'use strict';

  Dictionary = ash.ext.Dictionary;

  StateComponentMapping = ash.fsm.StateComponentMapping;

  Util = ash.ext.Util;

  ash.fsm.EntityState = (function() {

    /**
     * @type {ash.ext.Dictionary}
     */
    EntityState.prototype.providers = null;


    /**
     * @constructor
     */

    function EntityState() {
      this.providers = new Dictionary();
    }


    /**
     * Add a new ComponentMapping to this state. The mapping is a utility class that is used to
     * map a component type to the provider that provides the component.
     *
     * @param {Function} type The type of component to be mapped
     * @return {ash.fsm.StateComponentMapping} The component mapping to use when setting the provider for the component
     */

    EntityState.prototype.add = function(type) {
      return new StateComponentMapping(this, Util.getClassName(type));
    };


    /**
     * Get the ComponentProvider for a particular component type.
     *
     * @param {Function} type The type of component to get the provider for
     * @return {Object} The ComponentProvider
     */

    EntityState.prototype.get = function(type) {
      return this.providers[type];
    };


    /**
     * To determine whether this state has a provider for a specific component type.
     *
     * @param {Function} type The type of component to look for a provider for
     * @return {boolean} true if there is a provider for the given type, false otherwise
     */

    EntityState.prototype.has = function(type) {
      return this.providers[type] !== null;
    };

    return EntityState;

  })();


  /*
   * This is a state machine for an entity. The state machine manages a set of states,
   * each of which has a set of component providers. When the state machine changes the state, it removes
   * components associated with the previous state and adds components associated with the new state.
   */

  'use strict';

  Dictionary = ash.ext.Dictionary;

  EntityState = ash.fsm.EntityState;

  ash.fsm.EntityStateMachine = (function() {

    /**
     * @type {ash.ext.Dictionary}
     */
    EntityStateMachine.prototype.states = null;


    /**
    	 * The current state of the state machine.
     * @type {ash.fsm.EntityState}
     */

    EntityStateMachine.prototype.currentState = null;


    /*
     * The entity whose state machine this is
     * @type {ash.core.Entity}
     */

    EntityStateMachine.prototype.entity = null;


    /**
     * Creates an EntityStateMachine.
     * @constructor 
     * @param {ash.core.Entity}
     */

    function EntityStateMachine(_at_entity) {
      this.entity = _at_entity;
      this.states = new Dictionary();
    }


    /**
    		 * Add a state to this state machine.
    		 *
    		 * @param {string} name The name of this state - used to identify it later in the changeState method call.
    		 * @param {ash.core.Entity} state The state.
    		 * @return {ash.fsm.EntityStateMachine} This state machine, so methods can be chained.
     */

    EntityStateMachine.prototype.addState = function(name, state) {
      this.states[name] = state;
      return this;
    };


    /**
     * Create a new state in this state machine.
     *
     * @param {string} name The name of the new state - used to identify it later in the changeState method call.
     * @return {ash.fsm.EntityState} The new EntityState object that is the state. This will need to be configured with
     * the appropriate component providers.
     */

    EntityStateMachine.prototype.createState = function(name) {
      var state;
      state = new EntityState();
      this.states[name] = state;
      return state;
    };


    /**
     * Change to a new state. The components from the old state will be removed and the components
     * for the new state will be added.
     *
     * @param {string} name The name of the state to change to.
     */

    EntityStateMachine.prototype.changeState = function(name) {
      var newState, other, toAdd, type;
      newState = this.states[name];
      if (!newState) {
        throw new Error("Entity state " + name + " doesn't exist");
      }
      if (newState === this.currentState) {
        newState = null;
        return;
      }
      if (this.currentState) {
        toAdd = new Dictionary();
        for (type in newState.providers) {
          toAdd[type] = newState.providers[type];
        }
        for (type in this.currentState.providers) {
          other = toAdd[type];
          if (other && other.getIdentifier() === this.currentState.providers[type].getIdentifier()) {
            delete toAdd[type];
          } else {
            this.entity.remove(type);
          }
        }
      } else {
        toAdd = newState.providers;
      }
      for (type in toAdd) {
        this.entity.add(toAdd[type].getComponent());
      }
      return this.currentState = newState;
    };

    return EntityStateMachine;

  })();


  /*
   * Used by the SystemState class to create the mappings of Systems to providers via a fluent interface.
   */

  'use strict';

  ash.fsm.StateSystemMapping = (function() {

    /**
     * @type {Object}
     */
    StateSystemMapping.prototype.creatingState = null;


    /**
     * @type {Object}
     */

    StateSystemMapping.prototype.provider = null;


    /**
     * Used internally, the constructor creates a component mapping. The constructor
     * creates a SystemSingletonProvider as the default mapping, which will be replaced
     * by more specific mappings if other methods are called.
     *
     * @constructor
     * @param {Object} creatingState The SystemState that the mapping will belong to
     * @param {Object} type The System type for the mapping
     */

    function StateSystemMapping(_at_creatingState, _at_provider) {
      this.creatingState = _at_creatingState;
      this.provider = _at_provider;
    }


    /**
     * Applies the priority to the provider that the System will be.
     *
     * @param {number} priority The component provider to use.
     * @return {ash.fsm.StateSystemMapping} This StateSystemMapping, so more modifications can be applied.
     */

    StateSystemMapping.prototype.withPriority = function(priority) {
      this.provider.priority = priority;
      return this;
    };


    /**
     * Creates a mapping for the System type to a specific System instance. A
     * SystemInstanceProvider is used for the mapping.
     *
     * @param {Object} system The System instance to use for the mapping
     * @return {ash.fsm.StateSystemMapping} This StateSystemMapping, so more modifications can be applied
     */

    StateSystemMapping.prototype.addInstance = function(system) {
      return creatingState.addInstance(system);
    };


    /**
     * Creates a mapping for the System type to a single instance of the provided type.
     * The instance is not created until it is first requested. The type should be the same
     * as or extend the type for this mapping. A SystemSingletonProvider is used for
     * the mapping.
     *
     * @param {Function} type The type of the single instance to be created. If omitted, the type of the
     * mapping is used.
     * @return {ash.fsm.StateSystemMapping} This StateSystemMapping, so more modifications can be applied
     */

    StateSystemMapping.prototype.addSingleton = function(type) {
      return creatingState.addSingleton(type);
    };


    /**
     * Creates a mapping for the System type to a method call.
     * The method should return a System instance. A DynamicSystemProvider is used for
     * the mapping.
     *
     * @param {Function} method The method to provide the System instance.
     * @return {ash.fsm.StateSystemMapping}This StateSystemMapping, so more modifications can be applied.
     */

    StateSystemMapping.prototype.addMethod = function(method) {
      return creatingState.addMethod(method);
    };


    /*
     * Maps through to the addProvider method of the SystemState that this mapping belongs to
     * so that a fluent interface can be used when configuring entity states.
     *
     * @param {Object} provider The component provider to use.
     * @return {ash.fsm.StateSystemMapping} This StateSystemMapping, so more modifications can be applied.
     */

    StateSystemMapping.prototype.addProvider = function(provider) {
      return creatingState.addProvider(provider);
    };


    /*
     */

    return StateSystemMapping;

  })();


  /*
   * This System provider always returns the same instance of the component. The system
   * is passed to the provider at initialisation.
   */

  'use strict';

  ash.fsm.SystemInstanceProvider = (function() {

    /**
     * @type {Object}
     */
    SystemInstanceProvider.prototype.instance = null;


    /**
     * The priority at which the System should be added to the Engine
     * @type {number}
     */

    SystemInstanceProvider.prototype.priority = 0;


    /**
     * @constructor
     *
     * @param {Object} instance The instance to return whenever a System is requested.
     */

    function SystemInstanceProvider(_at_instance) {
      this.instance = _at_instance;
    }


    /**
     * Used to request a component from this provider
     *
     * @return {Object} The instance of the System
     */

    SystemInstanceProvider.prototype.getSystem = function() {
      return this.instance;
    };


    /**
     * Used to compare this provider with others. Any provider that returns the same component
     * instance will be regarded as equivalent.
     *
     * @type {Object} The instance
     */

    SystemInstanceProvider.prototype.getIdentifier = function() {
      return this.instance;
    };

    return SystemInstanceProvider;

  })();


  /*
   * This System provider always returns the same instance of the System. The instance
   * is created when first required and is of the type passed in to the constructor.
   */

  'use strict';

  ash.fsm.SystemSingletonProvider = (function() {

    /**
     * @type {Object}
     */
    SystemSingletonProvider.prototype.componentType = null;


    /**
     * @type {Object}
     */

    SystemSingletonProvider.prototype.instance = null;


    /**
     * @type {number}
     */

    SystemSingletonProvider.prototype.priority = 0;


    /**
     * @constructor
     *
     * @param {Function} type The type of the single System instance
     */

    function SystemSingletonProvider(type) {
      this.componentType = type;
    }


    /**
     * Used to request a System from this provider
     *
     * @return {Object} The single instance
     */

    SystemSingletonProvider.prototype.getSystem = function() {
      if (!this.instance) {
        this.instance = new this.componentType();
      }
      return this.instance;
    };


    /**
     * Used to compare this provider with others. Any provider that returns the same single
     * instance will be regarded as equivalent.
     *
     * @type {Object} The single instance
     */

    SystemSingletonProvider.prototype.getIdentifier = function() {
      return this.getSystem();
    };

    return SystemSingletonProvider;

  })();


  /*
   * Uses the enter frame event to provide a frame tick where the frame duration is the time since the previous frame.
   * There is a maximum frame time parameter in the constructor that can be used to limit
   * the longest period a frame can be.
   */

  'use strict';

  ash.tick.FrameTickProvider = (function(_super) {
    __extends(FrameTickProvider, _super);


    /**
     * @type {boolean}
     */

    FrameTickProvider.prototype.showStats = false;


    /**
     * @type {Function}
     */

    FrameTickProvider.prototype.begin = null;


    /**
     * @type {Function}
     */

    FrameTickProvider.prototype.end = null;


    /**
     * @type {Object}
     */

    FrameTickProvider.prototype.displayObject = null;


    /**
     * @type {number}
     */

    FrameTickProvider.prototype.previousTime = 0;


    /**
     * @type {number}
     */

    FrameTickProvider.prototype.maximumFrameTime = 0;


    /**
     * @type {boolean}
     */

    FrameTickProvider.prototype.isPlaying = false;


    /**
     * @type {Object}
     */

    FrameTickProvider.prototype.request = null;


    /**
     * Applies a time adjustement factor to the tick, so you can slow down or speed up the entire engine.
     * The update tick time is multiplied by this value, so a value of 1 will run the engine at the normal rate.
     * @type {number}
     */

    FrameTickProvider.prototype.timeAdjustment = 1;


    /**
     * @extends {ash.signals.Signal1}
     * @constructor
     * @param {Object} displayObject
     * @param {number} maximumFrameTime
     */

    function FrameTickProvider(_at_displayObject, _at_maximumFrameTime) {
      this.displayObject = _at_displayObject;
      this.maximumFrameTime = _at_maximumFrameTime;
      this.dispatchTick = __bind(this.dispatchTick, this);
      FrameTickProvider.__super__.constructor.apply(this, arguments);
      if (this.displayObject != null) {
        if (typeof this.displayObject['begin'] === 'function' && typeof this.displayObject['end'] === 'function') {
          this.showStats = true;
          this.begin = this.displayObject['begin'].bind(this.displayObject);
          this.end = this.displayObject['end'].bind(this.displayObject);
        }
      }
    }


    /**
     * Start
     */

    FrameTickProvider.prototype.start = function() {
      this.request = requestAnimationFrame(this.dispatchTick);
      this.isPlaying = true;
    };


    /**
     * Stop
     */

    FrameTickProvider.prototype.stop = function() {
      cancelAnimationFrame(this.request);
      this.isPlaying = false;
    };


    /**
     * dispatchTick
     @param {number} timestamp
     */

    FrameTickProvider.prototype.dispatchTick = function(timestamp) {
      var frameTime, temp;
      if (!this.isPlaying) {
        return;
      }
      if (this.showStats) {
        this.begin();
      }
      temp = this.previousTime || timestamp;
      this.previousTime = timestamp;
      frameTime = (timestamp - temp) * 0.001;
      this.dispatch(frameTime);
      this.request = requestAnimationFrame(this.dispatchTick);
      if (this.showStats) {
        this.end();
      }
    };

    return FrameTickProvider;

  })(ash.signals.Signal1);


  /*
   * An object pool for re-using components. This is not integrated in to Ash but is used dierectly by
   * the developer. It expects components to not require any parameters in their constructor.
   *
   * <p>Fetch an object from the pool with</p>
   *
   * <p>ComponentPool.get( ComponentClass );</p>
   *
   * <p>If the pool contains an object of the required type, it will be returned. If it does not, a new object
   * will be created and returned.</p>
   *
   * <p>The object returned may have properties set on it from the time it was previously used, so all properties
   * should be reset in the object once it is received.</p>
   *
   * <p>Add an object to the pool with</p>
   *
   * <p>ComponentPool.dispose( component );</p>
   *
   * <p>You will usually want to do this when removing a component from an entity. The remove method on the entity
   * returns the component that was removed, so this can be done in one line of code like this</p>
   *
   * <p>ComponentPool.dispose( entity.remove( component ) );</p>
   */

  'use strict';

  Dictionary = ash.ext.Dictionary;


  /**
   * constructor
   */

  ash.tools.ComponentPool = (function() {

    /**
     * @type {ash.core.Dictionary}
     */
    var getPool, pools;

    function ComponentPool() {}

    pools = new Dictionary();


    /**
     * @param {Function} componentClass
     * @return {ash.core.Dictionary}
     */

    getPool = function(componentClass) {
      var _ref;
      if ((_ref = componentClass.className, __indexOf.call(pools, _ref) >= 0)) {
        return pools[componentClass.className];
      } else {
        return pools[componentClass.className] = [];
      }
    };


    /**
     * Get an object from the pool.
     *
     * @param {Function} componentClass The type of component wanted.
     * @return {Object} The component.
     */

    ComponentPool.get = function(componentClass) {
      var pool;
      pool = getPool(componentClass);
      if (pool.length > 0) {
        return pool.pop();
      } else {
        return new componentClass();
      }
    };


    /**
     * Return an object to the pool for reuse.
     *
     * @param {Object} component The component to return to the pool.
     */

    ComponentPool.dispose = function(component) {
      var pool, type;
      if (component) {
        type = component.constructor;
        pool = getPool(type);
        pool.push(component);
      }
    };


    /**
     * Dispose of all pooled resources, freeing them for garbage collection.
     */

    ComponentPool.empty = function() {
      return pools = new Dictionary();
    };

    return ComponentPool;

  })();


  /*
   * A useful class for systems which simply iterate over a set of nodes, performing the same action on each node. This
   * class removes the need for a lot of boilerplate code in such systems. Extend this class and pass the node type and
   * a node update method into the constructor. The node update method will be called once per node on the update cycle
   * with the node instance and the frame time as parameters. e.g.
   *
   * <code>package;
   * class MySystem extends ListIteratingSystem<MyNode>
   * {
   *     public function new()
   *     {
   *         super(MyNode, updateNode);
   *     }
   *
   *     private function updateNode(node:MyNode, time:Float):Void
   *     {
   *         // process the node here
   *     }
   * }
   * </code>
   */

  'use strict';

  ash.tools.ListIteratingSystem = (function(_super) {
    __extends(ListIteratingSystem, _super);


    /**
     * @type {ash.core.NodeList}
     */

    ListIteratingSystem.prototype.nodeList = null;


    /**
     * @type {Function}
     */

    ListIteratingSystem.prototype.nodeClass = null;


    /**
     * @type {Function}
     */

    ListIteratingSystem.prototype.nodeUpdateFunction = null;


    /**
     * @type {Function}
     */

    ListIteratingSystem.prototype.nodeAddedFunction = null;


    /**
     * @type {Function}
     */

    ListIteratingSystem.prototype.nodeRemovedFunction = null;


    /**
     * @extends {ash.core.System}
     * @constructor
     * @param {Function} nodeClass
     * @param {Function} nodeUpdateFunction
     * @param {Function} nodeAddedFunction
     * @param {Function} nodeRemovedFunction
     */

    function ListIteratingSystem(nodeClass, nodeUpdateFunction, nodeAddedFunction, nodeRemovedFunction) {
      if (nodeAddedFunction == null) {
        nodeAddedFunction = null;
      }
      if (nodeRemovedFunction == null) {
        nodeRemovedFunction = null;
      }
      this.nodeClass = nodeClass;
      this.nodeUpdateFunction = nodeUpdateFunction;
      this.nodeAddedFunction = nodeAddedFunction;
      this.nodeRemovedFunction = nodeRemovedFunction;
    }


    /**
     * System is added to engine
     * @param {ash.core.Engine}
     */

    ListIteratingSystem.prototype.addToEngine = function(engine) {
      var node;
      this.nodeList = engine.getNodeList(this.nodeClass);
      if (this.nodeAddedFunction !== null) {
        node = this.nodeList.head;
        while (node) {
          this.nodeAddedFunction(node);
          node = node.next;
        }
        this.nodeList.nodeAdded.add(this.nodeAddedFunction);
      }
      if (this.nodeRemovedFunction !== null) {
        this.nodeList.nodeRemoved.add(this.nodeRemovedFunction);
      }
    };


    /**
     * System is removed from engine
     * @param {ash.core.Engine}
     */

    ListIteratingSystem.prototype.removeFromEngine = function(engine) {
      if (this.nodeAddedFunction !== null) {
        this.nodeList.nodeAdded.remove(this.nodeAddedFunction);
      }
      if (this.nodeRemovedFunction !== null) {
        this.nodeList.nodeRemoved.remove(this.nodeRemovedFunction);
      }
      this.nodeList = null;
    };


    /**
     * frame update
     * @param {number} time ms since last update
     */

    ListIteratingSystem.prototype.update = function(time) {
      var node;
      node = this.nodeList.head;
      while (node) {
        this.nodeUpdateFunction(node, time);
        node = node.next;
      }
    };

    return ListIteratingSystem;

  })(ash.core.System);

}).call(this);
